// REQUIRED for pdf.js on GitHub Pages
pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js";

const fileInput = document.getElementById("fileInput");
const compressBtn = document.getElementById("compressBtn");
const qualitySelect = document.getElementById("quality");
const bar = document.getElementById("bar");
const statusElement = document.getElementById("status");
const fileLabel = document.getElementById("fileLabel");

// --- UI Helper Functions ---

/** Updates the status message and progress bar. */
function updateStatus(message, progressPercentage = 0, isError = false, isSuccess = false) {
    statusElement.innerText = message;
    statusElement.className = isSuccess ? 'success-message' : '';
    bar.style.width = `${Math.min(100, Math.max(0, progressPercentage))}%`;
    
    // Add icon based on status
    let icon = '<i class="fas fa-info-circle"></i>';
    if (isError) {
        icon = '<i class="fas fa-exclamation-circle"></i>';
        bar.style.backgroundColor = '#ef4444'; // Red for error
    } else if (isSuccess) {
        icon = '<i class="fas fa-check-circle"></i>';
        bar.style.backgroundColor = '#22c55e'; // Green for success
    } else {
        bar.style.backgroundColor = '#22c55e'; // Green during compression
    }
    statusElement.innerHTML = `${icon} ${message}`;
}

/** Resets UI to initial state */
function resetUI() {
    fileInput.value = ''; // Clear file input
    updateStatus("Waiting for file selection...");
    fileLabel.innerHTML = '<i class="fas fa-cloud-upload-alt"></i><span>Click to select or drag & drop a PDF</span>';
    fileLabel.classList.remove('file-selected');
    compressBtn.disabled = true;
}

// --- File Selection & Drag/Drop Logic ---

fileInput.addEventListener('change', () => {
    const file = fileInput.files[0];
    if (file) {
        fileLabel.innerHTML = `<i class="fas fa-file-pdf"></i><span>File Selected: **${file.name}**</span>`;
        fileLabel.classList.add('file-selected');
        compressBtn.disabled = false;
        updateStatus(`File selected: ${file.name}`);
    } else {
        resetUI();
    }
});

// Drag and Drop implementation
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    fileLabel.addEventListener(eventName, preventDefaults, false);
});

function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
}

['dragenter', 'dragover'].forEach(eventName => {
    fileLabel.addEventListener(eventName, () => fileLabel.classList.add('dragging'), false);
});

['dragleave', 'drop'].forEach(eventName => {
    fileLabel.addEventListener(eventName, () => fileLabel.classList.remove('dragging'), false);
});

fileLabel.addEventListener('drop', handleDrop, false);

function handleDrop(e) {
    const dt = e.dataTransfer;
    const files = dt.files;

    if (files.length) {
        const pdfFile = Array.from(files).find(f => f.type === 'application/pdf');
        if (pdfFile) {
            // Set the dropped file to the file input
            fileInput.files = dt.files; 
            fileInput.dispatchEvent(new Event('change')); // Trigger change event
        } else {
            updateStatus("Please drop a valid PDF file (.pdf).", 0, true);
        }
    }
}


// --- Compression Logic ---

compressBtn.addEventListener("click", compress);

async function compress() {
    const file = fileInput.files[0];
    const quality = parseFloat(qualitySelect.value);

    if (!file) {
        updateStatus("Please select a PDF file first.", 0, true);
        return;
    }
    
    // Disable button to prevent re-pressing
    compressBtn.disabled = true;

    try {
        updateStatus("Loading PDF…", 5);

        const buffer = await file.arrayBuffer();
        
        // Use a hidden canvas for rendering
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        // Load PDF using pdf.js
        const pdf = await pdfjsLib.getDocument({ data: buffer }).promise;
        const newPdf = await PDFLib.PDFDocument.create();
        const total = pdf.numPages;

        for (let i = 1; i <= total; i++) {
            const pageIndex = i - 1;
            updateStatus(`Compressing page ${i} of ${total}…`, 5 + (i / total) * 80);

            const page = await pdf.getPage(i);
            const viewport = page.getViewport({ scale: 1 }); // Use scale 1 for original dimensions

            canvas.width = viewport.width;
            canvas.height = viewport.height;

            // Render page to canvas
            await page.render({ canvasContext: ctx, viewport }).promise;

            // Convert canvas content to JPEG with specified quality
            // The quality parameter (0.0 to 1.0) is the actual compression factor.
            const imgData = canvas.toDataURL("image/jpeg", quality); 
            const img = await newPdf.embedJpg(imgData);

            // Add new page to PDF-LIB document and draw the compressed image
            const pdfPage = newPdf.addPage([canvas.width, canvas.height]);
            pdfPage.drawImage(img, {
                x: 0,
                y: 0,
                width: canvas.width,
                height: canvas.height
            });
        }

        updateStatus("Finalizing and saving compressed PDF…", 95);

        const finalPdf = await newPdf.save();
        download(finalPdf, file.name);

        updateStatus(`Compression Complete! File saved as 'compressed_${file.name}'.`, 100, false, true);
        // Do not reset UI after success, allow user to download, but re-enable button
        // compressBtn.disabled = false; // Re-enable for next attempt
        resetUI(); // Resetting for a clean new start is better
        
    } catch (e) {
        console.error("Compression Error:", e);
        updateStatus(`An error occurred during compression: ${e.message}`, 100, true);
        compressBtn.disabled = false; // Re-enable button after error
    }
}

function download(bytes, originalName) {
    const blob = new Blob([bytes], { type: "application/pdf" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "compressed_" + originalName;
    link.click();
    // Clean up the object URL
    URL.revokeObjectURL(link.href);
}

// Set initial state
resetUI();
